;;
;; Z1 -- bootstrapping
;;

;; This program in the Z0 language implements a programming system
;; that is nothing more than Z0 plus macros and a primitive
;; read-eval-print loop.

;;; Debug output

(fun (dbg-chars buf len)
  (syscall 1 2 buf len))

(mem dbg-buf 40)

(fun (dbg-char ch)
  (b@= dbg-buf ch)
  (dbg-chars dbg-buf 1))

(fun (dbg-nibble n)
  (goto hex (> n 9))
  (dbg-char (+ n #0))
  (return)
hex
  (dbg-char (+ n #a -10)))

(fun (dbg-byte b)
  (var hi (/ b 16))
  (var lo (- b (* hi 16)))
  (dbg-nibble hi)
  (dbg-nibble lo))

(fun (dbg-strlen s)
  (var l 0)
again
  (goto done (not (b@ s l)))
  (= l (+ l 1))
  (goto again)
done
  (return l))

(fun (dbg-str s)
  (dbg-chars s (dbg-strlen s)))

(fun (dbg-nl)
  (dbg-char 10))

(fun (dbg-num i)
  (var p dbg-buf)
  (var b dbg-buf)
  (var t)
next-digit
  (b@= p (+ (% i 10) 48))
  (= p (+ p 1))
  (= i (/ i 10))
  (goto next-digit i)
  (b@= p 0)
reverse-next
  (= p (- p 1))
  (= t (b@ b))
  (b@= b (b@ p))
  (b@= p t)
  (= b (+ b 1))
  (goto reverse-next (> p b))
  (dbg-str dbg-buf))

;;; Aborting

(fun (abort)
  (syscall 60 1))

(fun (abort-if-not cond)
  (goto out cond)
  (abort)
out)

;;; Input

;; The bootstrap compiler only reads from stdin, with a simple buffer.

(const input-bufsize 1024)
(const input-eof -1)

(mem input-buf input-bufsize)
(var input-cur)
(var input-end)

(fun (input-fillbuf)
  (var n (syscall 0 0 input-buf input-bufsize))
  (abort-if-not (>= n 0))
  (= input-cur input-buf)
  (= input-end (+ input-buf n)))

(fun (input)
  (var r)
  (goto non-empty (< input-cur input-end))
  (input-fillbuf)
  (goto non-empty (< input-cur input-end))
  (return input-eof)
non-empty
  (= r (b@ input-cur))
  (= input-cur (+ input-cur 1))
  (return r))

(fun (input-undo)
  (goto empty-buf (== input-cur input-buf))
  (= input-cur (- input-cur 1))
empty-buf)

;;; Tokenization

(const token-eof -1)
(const token-symbol 0)
(const token-punct 1)
(const token-inum 2)
(const token-dnum 3)
(const token-string 4)

(const token-max 512)
(mem token token-max)
(var token-type)

(fun (skip-whitespace)
  (var c)
again
  (= c (input))
  (goto again (== c 32))
  (goto again (== c 9))
  (goto again (== c 10))
  (goto comment (== c #;))
  (input-undo)
  (return)
comment
  (= c (input))
  (goto again (== c 10))
  (goto comment))

(fun (read-token)
  (var c)
  (var t 0)
  (skip-whitespace)
  (= c (input))
  (goto eof (== c input-eof))
  (goto punct (== c #())
  (goto punct (== c #)))
  (goto symbol)
eof
  (= token-type token-eof)
  (return)
punct
  (b@= token t c)
  (b@= token (+ t 1) 0)
  (= token-type token-punct)
  (return)
symbol
  (goto symbol-done (== c input-eof))
  (goto symbol-done (== c 32))
  (goto symbol-done (== c 9))
  (goto symbol-done (== c 10))
  (goto symbol-done (== c #;))
  (goto symbol-done (== c #())
  (goto symbol-done (== c #)))
  (b@= token t c)
  (= t (+ t 1))
  (= c (input))
  (goto symbol)
symbol-done
  (input-undo)
  (b@= token t 0)
  (= token-type token-symbol)
  (return))

;;; Lists, aka S-Expressions

(const off-type 0)
(const type-pair 0)
(const type-sym  1)
(const type-inum 2)
(const type-str  3)
(const type-spec 4)

(const exp-size 4096)
(mem exp-pool exp-size)
(var exp-ptr)

(var exp-nil-obj)

(fun (init-exp)
  (= exp-ptr exp-pool)
  (= exp-nil-obj (exp-alloc 1))
  (@= exp-nil-obj 0 type-spec))

(fun (exp-alloc size)
  (var res exp-ptr)
  (= exp-ptr (+ exp-ptr (* size 8)))
  (abort-if-not (< exp-ptr (+ exp-pool exp-size)))
  (return res))

(fun (exp-nil)
  (return exp-nil-obj))

(fun (exp-is-nil e)
  (return (== e exp-nil-obj)))

(const off-pair-first  8)
(const off-pair-rest  16)
(const size-pair      24)

(fun (exp-pair first rest)
  (var p (exp-alloc size-pair))
  (@= p off-type type-pair)
  (@= p off-pair-first first)
  (@= p off-pair-rest rest)
  (return p))

(fun (exp-is-pair e)
  (return (== (@ e off-type) type-pair)))

(fun (exp-first e)
  (return (@ e off-pair-first)))

(fun (exp-rest e)
  (return (@ e off-pair-rest)))

(const off-inum-val  8)
(const size-inum    16)

(fun (exp-inum val)
  (var p (exp-alloc size-inum))
  (@= p off-type type-inum)
  (@= p off-inum-val val)
  (return p))

(fun (exp-is-inum e)
  (return (== (@ e off-type) type-inum)))

(fun (exp-inum-val e)
  (return (@ e off-inum-val)))

(fun (exp-write e)
  (var need-space 0)

  (goto list (exp-is-pair e))
  (goto not-list (not (exp-is-nil e)))

list
  (dbg-str "(")
list-next
  (goto list-end (not (exp-is-pair e)))
  (goto list-no-space (not need-space))
  (dbg-str " ")
list-no-space
  (exp-write (exp-first e))
  (= need-space 1)
  (= e (exp-rest e))
  (goto list-next)
list-end
  (goto list-end-nil (exp-is-nil e))
  (dbg-str " . ")
  (exp-write e)
list-end-nil
  (dbg-str ")")
  (return)

not-list
  (goto not-inum (not (exp-is-inum e)))
  (dbg-num (exp-inum-val e))
  (return)
not-inum
  (dbg-str "<???>"))

;;; Emitting code

(const code-size 1024)
(mem code code-size)
(var code-ptr)

(fun (init-code)
  (= code-ptr code))

(fun (emit-8 b)
  (abort-if-not (< code-ptr (+ code code-size)))
  (b@= code-ptr b)
  (= code-ptr (+ code-ptr 1)))

(fun (emit-16 w)
  (emit-8 w)
  (emit-8 (>> w 8)))

(fun (emit-32 q)
  (emit-16 q)
  (emit-16 (>> q 16)))

(fun (emit-64 t)
  (emit-32 t)
  (emit-32 (>> t 32)))

(fun (emit-ret)
  (emit-8 0xC3))

;;; Main

(fun (main)
  (init-exp)
  (exp-write (exp-pair (exp-inum 1)
                       (exp-pair (exp-inum 2) (exp-nil))))
  (dbg-nl))
