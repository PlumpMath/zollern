;;; Z1 compiler

(code abort
  (call print)
  (set l0 125)
  (jmp sys-exit))

;; Memory
;;
;; (data p (sizeof mem-pool))
;;
;; (mem-pool-init p pool-size)
;; (mem-pool-alloc p size)
;; (mem-pool-reset p)
;; (mem-pool-destroy p)

(defstruct mem-pool
  (u64 mp-start)
  (u64 mp-end)
  (u64 mp-next))

(code mem-pool-init
  (push x1)
  (push x2)
  (set x1 l0)
  (set x2 l1)
  (set l0 0)
  (set l2 3) ; PROT_READ | PROT_WRITE
  (set l3 0x22) ; MAP_ANONYMOUS | MAP_PRIVATE
  (set l4 0)
  (set l5 0)
  (call sys-mmap)
  (cmp l0 0)
  (jl .err)
  (set (mp-start x1) l0)
  (set (mp-next x1) l0)
  (add l0 x2)
  (set (mp-end x1) l0)
  (pop x2)
  (pop x1)
  (ret)
.err
  (let l0 (u8 .message))
  (jmp abort)
.message
  (1 "Can't get memory\n" 0))

(code mem-pool-alloc
  (set l2 (mp-next l0))
  (add l1 l2)
  (set l3 (mp-end l0))
  (cmp l1 l3)
  (jge .oom)
  (set (mp-next l0) l1)
  (set l0 l2)
  (ret)
.oom
  (let l0 (u8 .message))
  (jmp abort)
.message
  (1 "Out of pool memory\n" 0))

(code mem-pool-reset
  (set l1 (mp-start l0))
  (set (mp-next l0) l1)
  (ret))

(code mem-pool-destroy
  (set l1 (mp-end l0))
  (set l0 (mp-start l0))
  (sub l1 l0)
  (jmp sys-munmap))

;; Reading files

;; (file-open fb name)
;; (file-close fb)

(defstruct file-buffer
  (u64 fb-start)
  (u64 fb-end)
  (u64 fb-ptr))

(code file-open
  (push x0)
  (push x1)
  (set x1 l0)
  (sub sp (sizeof sys-fstat-buf))
  (set l0 l1)
  (set l1 0)
  (call sys-open)
  (cmp l0 0)
  (jl .err)
  (set x0 l0)
  (set l1 sp)
  (call sys-fstat)
  (cmp l0 0)
  (jl .err)
  (set l0 0)
  (set l1 (st_size sp))
  (set l2 1) ; PROT_READ
  (set l3 2) ; MAP_PRIVATE
  (set l4 x0)
  (set l5 0)
  (call sys-mmap)
  (cmp l0 0)
  (jl .err)
  (set (fb-start x1) l0)
  (set (fb-ptr x1) l0)
  (set l1 (st_size sp))
  (add l0 l1)
  (set (fb-end x1) l0)
  (add sp (sizeof sys-fstat-buf))
  (set l0 x0)
  (call sys-close)
  (pop x1)
  (pop x0)
  (ret)
.err
  (let l0 (u8 .message))
  (jmp abort)
.message
  (1 "Can't read file\n" 0))

;; Tokens

(defstruct token-struct
  (u64 tk-buf)
  (u8  tk-kind)
  (u8  tk-unused-1)
  (u8  tk-unused-2)
  (u8  tk-unused-3))

(def tk-kind-eof    0)
(def tk-kind-open   1)
(def tk-kind-close  2)
(def tk-kind-symbol 3)
(def tk-kind-string 4)

(def (getchar ?dst ?ptr ?end ?eof-label)
  (cmp ?ptr ?end)
  (jge ?eof-label)
  (set ?dst (u8 ?ptr))
  (add ?ptr 1))

(code next-token
  ;; l0: file-buffer
  ;; l1: token-struct
  ;;
  ;; Reads the next token from file-buffer l0 into token-struct l1.
  ;;
  (set l2 (fb-ptr l0))
  (set l3 (fb-end l0))
.skip-whitespace
  (getchar l4 l2 l3 .eof)
  (cmp l4 :spc)
  (jle .skip-whitespace)
  (cmp l4 :sc)
  (jne .not-comment)
.skip-comment
  (getchar l4 l2 l3 .eof)
  (cmp l4 :nl)
  (je .skip-whitespace)
  (jmp .skip-comment)
.not-comment
  (cmp l4 :lp)
  (jne .not-open)
  (set l5 tk-kind-open)
  (jmp .out)
.not-open
  (cmp l4 :rp)
  (jne .not-close)
  (set l5 tk-kind-close)
  (jmp .out)
.not-close
  (cmp l4 :dq)
  (jne .not-string)
  (set l5 (tk-buf l1))
.next-string-char
  (getchar l4 l2 l3 .eof-in-string)
  (cmp l4 :dq)
  (je .end-string)
  (cmp l4 :bs)
  (jne .store-string-char)
  (getchar l4 l2 l3 .eof-in-string)
  (cmp l4 :bs)
  (je .store-string-char)
  (cmp l4 :dq)
  (je .store-string-char)
  (cmp l4 :n)
  (jne .not-newline-escape)
  (set l4 :nl)
  (jmp .store-string-char)
.not-newline-escape
  (cmp l4 :t)
  (jne .store-string-char)
  (set l4 :ht)
.store-string-char
  (set (u8 l5) l4)
  (add l5 1)
  (jmp .next-string-char)
.end-string
  (set l4 0)
  (set (u8 l5) l4)
  (set l5 tk-kind-string)
  (jmp .out)
.not-string
  (set l5 (tk-buf l1))
.store-sym-char
  (set (u8 l5) l4)
  (add l5 1)
  (getchar l4 l2 l3 .end-symbol)
  (cmp l4 :spc)
  (jle .end-symbol-put-back)
  (cmp l4 :lp)
  (je .end-symbol-put-back)
  (cmp l4 :rp)
  (je .end-symbol-put-back)
  (jmp .store-sym-char)
.end-symbol-put-back
  (sub l2 1)
.end-symbol
  (set l4 0)
  (set (u8 l5) l4)
  (set l5 tk-kind-symbol)
  (jmp .out)
.eof
  (set l5 tk-kind-eof)
.out
  (set (tk-kind l1) l5)
  (set (fb-ptr l0) l2)
  (ret)
.eof-in-string
  (let l0 (u8 .eof-in-string-message))
  (jmp abort)
.eof-in-string-message
  (1 "Unexpected end of file in string\n" 0))

;;; Compiler context

;; All functions that use a compiler context expect it in x5.

(defstruct compiler-context
  (mem-pool cc-pool)
  (u64 cc-symbols)
  (token-struct cc-token)
  (u64 cc-codebuf)
  (u64 cc-codebuf-end)
  (u32 cc-stackoff)
  (u32 cc-next-frame-offset)
  (u8 cc-tokenbuf 1024))

;; Expressions

(def EXP-POOL-SIZE (* 10 1024 1024))
(def EXP-HASH-SIZE 1023)

(def exp-type-pair   0)
(def exp-type-symbol 1)
(def exp-type-string 2)
(def exp-type-number 3)

(defstruct exp-base
  (u32 exp-type))

(defstruct exp-symbol
  (exp-base base)
  (u64 exp-sym-link)
  (u64 exp-sym-val)
  (u8  exp-sym-type))

(def exp-sym-type-undef 0)
(def exp-sym-type-local 1)

(def (exp-sym-define ?sym ?type ?val)
  (cmp (exp-sym-type ?sym) exp-sym-type-undef)
  (jne error-redef)
  (set (exp-sym-type ?sym) ?type)
  (set (exp-sym-val ?sym) ?val))

(code error-redef
  (set l0 l1)
  (call exp-write)
  (let l0 (u8 .redef-error-string))
  (jmp abort)
.redef-error-string
  (1 "\nredefined\n" 0))

(code error-undef
  (set l0 l1)
  (call exp-write)
  (let l0 (u8 .redef-error-string))
  (jmp abort)
.redef-error-string
  (1 "\nundefined\n" 0))

(defstruct exp-string
  (exp-base base))

(defstruct exp-pair
  (exp-base base)
  (u64 exp-first)
  (u64 exp-rest))

(defstruct exp-number
  (exp-base base)
  (s64 exp-num-val))

(code exp-init
  (let l0 (cc-pool x5))
  (set l1 EXP-POOL-SIZE)
  (call mem-pool-init)
  (jmp exp-reset))

(code exp-reset
  (let l0 (cc-pool x5))
  (set l1 (mp-start l0))
  (set (mp-next l1) l0)
  (set l1 (* EXP-HASH-SIZE (sizeof u64)))
  (call mem-pool-alloc)
  (set (cc-symbols x5) l0)
  (set l1 EXP-HASH-SIZE)
  (set l2 0)
  (jmp .test)
.loop
  (set (u64 l0) l2)
  (add l0 (sizeof u64))
  (sub l1 1)
.test
  (cmp l1 0)
  (jg .loop)
  (ret))

(code exp-make-pair
  (push x0)
  (push x1)
  (set x0 l0)
  (set x1 l1)
  (let l0 (cc-pool x5))
  (set l1 (sizeof exp-pair))
  (call mem-pool-alloc)
  (set l1 exp-type-pair)
  (set (exp-type l0) l1)
  (set (exp-first l0) x0)
  (set (exp-rest l0) x1)
  (pop x1)
  (pop x0)
  (ret))

(code exp-make-number
  (push x0)
  (set x0 l0)
  (let l0 (cc-pool x5))
  (set l1 (sizeof exp-number))
  (call mem-pool-alloc)
  (set l1 exp-type-number)
  (set (exp-type l0) l1)
  (set (exp-num-val l0) x0)
  (pop x0)
  (ret))

(code exp-make-with-string
  ;; l0 - string
  ;; l1 - header size
  (push x0)
  (push x1)
  (push x2)
  (set x0 l0)
  (set x1 l1)
  (call strlen)
  (add l0 1)
  (add l0 x1)
  (set l1 l0)
  (let l0 (cc-pool x5))
  (call mem-pool-alloc)
  (set x2 l0)
  (add l0 x1)
  (set l1 x0)
  (call strcpy)
  (set l0 x2)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret))

(code exp-make-string
  ;; l0 - string
  (set l1 (sizeof exp-string))
  (call exp-make-with-string)
  (set l1 exp-type-string)
  (set (exp-type l0) l1)
  (ret))

(code exp-intern
  ;; l0 - name
  (push x0) ;; name
  (push x1) ;; hash(name)
  (push x2) ;; candidate symbol
  (set x0 l0)
  ;; compute hash of x0
  (set l0 5381)
  (set l1 x0)
.hash-loop
  (set l2 (u8 l1))
  (cmp l2 0)
  (je .hash-done)
  (mul l0 33)
  (xor l0 l2)
  (add l1 1)
  (jmp .hash-loop)
.hash-done
  (set l2 0)
  (set l1 EXP-HASH-SIZE)
  (sdiv l1)
  (set x1 l2)
  (set l0 (cc-symbols x5))
  (set x2 (u64 l0 x1))
  (jmp .find-test)
.find-loop
  (set x2 (exp-sym-link x2))
.find-test
  (set l0 x2)
  (cmp l0 0)
  (je .not-found)
  (add l0 (sizeof exp-symbol))
  (set l1 x0)
  (call streq)
  (cmp l0 0)
  (je .find-loop)
  (set l0 x2)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret)
.not-found
  (set l0 x0)
  (set l1 (sizeof exp-symbol))
  (call exp-make-with-string)
  (set (exp-type l0) exp-type-symbol)
  (set (exp-sym-type l0) exp-sym-type-undef)
  (set l1 (cc-symbols x5))
  (set l2 (u64 l1 x1))
  (set (exp-sym-link l0) l2)
  (set (u64 l1 x1) l0)
  (pop x2)
  (pop x1)
  (pop x0)
  (ret))

(code exp-list-reverse
  (set l1 0)
.loop
  (cmp l0 0)
  (je .done)
  (set l2 (exp-rest l0))
  (set (exp-rest l0) l1)
  (set l1 l0)
  (set l0 l2)
  (jmp .loop)
.done
  (set l0 l1)
  (ret))

(code exp-read
  (let l1 (cc-token x5))
  (let l2 (cc-tokenbuf x5))
  (set (tk-buf l1) l2)
  (push x0)
  (push x1)
  (set x0 l0)
  (set x1 l1)
  (call next-token)
  (call .read1)
  (pop x1)
  (pop x0)
  (ret)
.read1
  (set l0 (tk-kind x1))
  (cmp l0 tk-kind-open)
  (jne .not-open)
  (push x2)
  (set x2 0)
.list-loop
  (set l0 x0)
  (set l1 x1)
  (call next-token)
  (set l0 (tk-kind x1))
  (cmp l0 tk-kind-eof)
  (je .eof-in-list)
  (cmp l0 tk-kind-close)
  (je .list-done)
  (call .read1)
  (set l1 x2)
  (call exp-make-pair)
  (set x2 l0)
  (jmp .list-loop)
.eof-in-list
  (let l0 (u8 .eof-in-list-message))
  (jmp abort)
.eof-in-list-message
  (1 "Unexpected end of file in list\n" 0)
.list-done
  (set l0 x2)
  (call exp-list-reverse)
  (pop x2)
  (ret)
.not-open
  (cmp l0 tk-kind-symbol)
  (jne .not-symbol)
  (set l1 (tk-buf x1))
  (set l3 (u8 l1))
  (cmp l3 :-)
  (jne .no-sign)
  (add l1 1)
.no-sign
  (set l2 0)
.number-loop
  (set l3 (u8 l1))
  (cmp l3 0)
  (je .number-done)
  (cmp l3 :0)
  (jl .symbol)
  (cmp l3 :9)
  (jg .symbol)
  (sub l3 :0)
  (mul l2 10)
  (add l2 l3)
  (add l1 1)
  (jmp .number-loop)
.number-done
  (set l1 (tk-buf x1))
  (set l3 (u8 l1))
  (cmp l3 :-)
  (jne .dont-negate)
  (neg l2)
.dont-negate
  (set l0 l2)
  (jmp exp-make-number)
.symbol
  (set l0 (tk-buf x1))
  (jmp exp-intern)
.not-symbol
  (cmp l0 tk-kind-eof)
  (jne .not-eof)
  (set l0 0)
  (ret)
.not-eof
  (set l0 (tk-buf x1))
  (jmp exp-make-string))

(data exp-write-strbuf 20)

(code exp-write
  (cmp l0 0)
  (jne .not-empty-list)
  (let l0 (u8 .empty-list-string))
  (jmp print)
.empty-list-string
  (1 "()" 0)
.not-empty-list
  (set l1 (exp-type l0))
  (cmp l1 exp-type-pair)
  (jne .not-list)
.list
  (push x0)
  (set x0 l0)
  (let l0 (u8 .open-paren-string))
  (call print)
  (jmp .list-loop-no-space)
.list-loop
  (let l0 (u8 .space-string))
  (call print)
.list-loop-no-space
  (set l0 (exp-first x0))
  (call exp-write)
  (set x0 (exp-rest x0))
  (cmp x0 0)
  (je .list-done)
  (set l0 (exp-type x0))
  (cmp l0 exp-type-pair)
  (je .list-loop)
  (let l0 (u8 .improper-end-string))
  (call print)
  (set l0 x0)
  (call exp-write)
.list-done
  (pop x0)
  (let l0 (u8 .close-paren-string))
  (jmp print)
.open-paren-string
  (1 "(" 0)
.space-string
  (1 " " 0)
.close-paren-string
  (1 ")" 0)
.improper-end-string
  (1 " . " 0)
.not-list
  (cmp l1 exp-type-string)
  (jne .not-string)
  (add l0 (sizeof exp-string))
  (push x0)
  (set x0 l0)
  (let l0 (u8 .double-quote-string))
  (call print)
  (set l0 x0)
  (call print)
  (let l0 (u8 .double-quote-string))
  (call print)
  (pop x0)
  (ret)
.double-quote-string
  (1 "\"" 0)
.not-string
  (cmp l1 exp-type-symbol)
  (jne .not-symbol)
  (add l0 (sizeof exp-symbol))
  (jmp print)
.not-symbol
  (cmp l1 exp-type-number)
  (jne .not-number)
  (set l0 (exp-num-val l0))
  (set l4 l0)
  (cmp l0 0)
  (jge .positive)
  (neg l0)
.positive
  (let l1 (u8 (+ exp-write-strbuf 19)))
  (set l2 0)
  (set l3 10)
  (set (u8 l1) l2)
.number-loop
  (add l1 -1)
  (set l2 0)
  (udiv l3)
  (add l2 :0)
  (set (u8 l1) l2)
  (cmp l0 0)
  (jne .number-loop)
  (cmp l4 0)
  (jge .no-sign)
  (set l2 :-)
  (add l1 -1)
  (set (u8 l1) l2)
.no-sign
  (set l0 l1)
  (jmp print)
.not-number
  (let l0 (u8 .unknown-string))
  (jmp print)
.unknown-string
  (1 "<unknown>" 0))

;; Code generation

(data
  codebuf (* 1024 1024)
  codebuf-end)

(code code-init
  (let l0 (u8 codebuf))
  (set (cc-codebuf x5) l0)
  (let l1 (u8 (- codebuf-end 100)))
  (set (cc-codebuf-end x5) l1)
  (ret))

(def (size-to-type  1) u8)
(def (size-to-type  4) u32)
(def (size-to-type -4) u32)
(def (size-to-type  8) u64)

(def (size-to-offset  1) 1)
(def (size-to-offset  4) 4)
(def (size-to-offset -4) 4)
(def (size-to-offset  8) 8)

(def (code-emit ?ptr ?insn)
  (code-emit-1 ?ptr ?insn ()))

(def (code-emit ?ptr ?insn ?repl)
  (code-emit-1 ?ptr ?insn (?repl)))

(def (code-emit-1 ?ptr (?size) ?repl)
  (begin))

(def (code-emit-1 ?ptr (?size ?first . ?rest) ?repl)
  (sel (== ?size 8) (error "can't emit 64 bit literals")
                    (begin))
  (set ((size-to-type ?size) ?ptr) ?first)
  (add ?ptr (size-to-offset ?size))
  (code-emit-1 ?ptr (?size . ?rest) ?repl))

(def (code-emit-1 ?ptr (?size ?first) (?repl))
  (set ((size-to-type ?size) ?ptr) ?repl)
  (add ?ptr (size-to-offset ?size)))

(def (code-emit-1 ?ptr (begin ?first . ?rest) ?repl)
  (code-emit-1 ?ptr ?first ())
  (code-emit-1 ?ptr (begin . ?rest) ?repl))

(def (code-emit-1 ?ptr (begin ?first) ?repl)
  (code-emit-1 ?ptr ?first ?repl))

(def (code-check ?ptr)
  (push l1)
  (set l1 (cc-codebuf-end x5))
  (cmp ?ptr l1)
  (jae too-much-code)
  (pop l1))

(code too-much-code
  (let l0 (u8 .too-big-string))
  (jmp abort)
.too-big-string
  (1 "too much code!" 0))

;; Compilation

(code syntax
  (set l0 l1)
  (call exp-write)
  (let l0 (u8 .syntax-error-string))
  (jmp abort)
.syntax-error-string
  (1 "\nsyntax error\n" 0))

(def (assert-type ?exp ?type ?error)
  (cmp ?exp 0)
  (je ?error)
  (cmp (exp-type ?exp) ?type)
  (jne ?error))

(def (parse-eol ?ptr)
  (parse-eol ?ptr syntax))

(def (parse-eol ?ptr ?error)
  (cmp ?ptr 0)
  (jne ?error))

(def (parse-exp ?ptr ?res)
  (parse-exp ?ptr ?res syntax))

(def (parse-exp ?ptr ?res ?error)
  (assert-type ?ptr exp-type-pair ?error)
  (set ?res (exp-first ?ptr))
  (set ?ptr (exp-rest ?ptr)))

(def (parse-num ?ptr ?res ?max)
  (parse-num ?ptr ?res ?max syntax))

(def (parse-num ?ptr ?res ?max ?error)
  (parse-exp ?ptr ?res ?error)
  (assert-type ?res exp-type-number ?error)
  (set ?res (exp-num-val ?res))
  (cmp ?res ?max)
  (jae ?error))

(def (parse-symbol ?ptr ?res)
  (parse-symbol ?ptr ?res  syntax))

(def (parse-symbol ?ptr ?res ?error)
  (parse-exp ?ptr ?res)
  (assert-type ?res exp-type-symbol ?error))

(code comp-exprs
  (cmp l1 0)
  (je syntax)
  (set l2 (exp-type l1))
  (cmp l2 exp-type-pair)
  (jne syntax)
  (push l1)
  (set l2 0)
  (set l1 (exp-rest l1))
  (cmp l1 0)
  (je .done)
  (call comp-exprs)
  (code-emit l0 (push l0))
  (set l2 8)
  (add (cc-stackoff x5) l2)
  (set l2 l1)
.done
  (pop l1)
  (set l1 (exp-first l1))
  (push l2)
  (call comp-expr)
  (pop l1)
  (add l1 1)
  (ret))

(code comp-begin
  (push x0)
  (set x0 l1)
.loop
  (parse-exp x0 l1)
  (call comp-expr)
.test
  (cmp x0 0)
  (jne .loop)
  (pop x0)
  (ret))

(code comp-if
  (push x0)
  (push x1)
  (set x0 l1)
  (parse-exp x0 l1)
  (call comp-expr)
  (code-emit l0 (cmp l0 0))
  (code-emit l0 (je 0x1234))
  (set x1 l0)
  (parse-exp x0 l1)
  (call comp-expr)
  (code-emit l0 (jmp 0x1234))
  (set l1 l0)
  (sub l1 x1)
  (set (u32 x1 -4) l1)
  (set x1 l0)
  (parse-exp x0 l1)
  (call comp-expr)
  (set l1 l0)
  (sub l1 x1)
  (set (u32 x1 -4) l1)
  (pop x1)
  (pop x0)
  (ret))

(code comp-unop-table
  (8 comp-unop-neg)  ; 0
  (8 comp-unop-not)  ; 1
  comp-unop-table-end)

(def comp-unop-table-size (>> (- comp-unop-table-end comp-unop-table) 3))

(code comp-unop
  (parse-num l1 l2 comp-unop-table-size)
  (parse-exp l1 l1)
  (push l2)
  (call comp-expr)
  (pop l2)
  (set l1 comp-unop-table)
  (set l1 (u64 l1 l2))
  (jmp l1))

(code comp-unop-neg
  (code-emit l0 (neg l0))
  (ret))

(code comp-unop-not
  (code-emit l0 (not l0))
  (ret))

(code comp-polop-table
  (8 comp-polop-add)  ; 0
  (8 comp-polop-sub)  ; 1
  (8 comp-polop-mul)  ; 2
  (8 comp-polop-div)  ; 3
  comp-polop-table-end)

(def comp-polop-table-size (>> (- comp-polop-table-end comp-polop-table) 3))

(code comp-polop
  (push x0)
  (push x1)
  (parse-num l1 l2 comp-polop-table-size)
  (set x0 comp-polop-table)
  (set x0 (u64 x0 l2))
  (call comp-exprs)
  (set x1 l1)
  (jmp .test)
.loop
  (code-emit l0 (pop l1))
  (set l2 -8)
  (add (cc-stackoff x5) l2)
  (call x0)
  (sub x1 1)
.test
  (cmp x1 1)
  (jg .loop)
  (pop x1)
  (pop x0)
  (ret))

(code comp-polop-add
  (code-emit l0 (add l0 l1))
  (ret))

(code comp-polop-sub
  (code-emit l0 (sub l0 l1))
  (ret))

(code comp-polop-mul
  (code-emit l0 (mul l0 l1))
  (ret))

(code comp-polop-div
  (code-emit l0 (sign-extend))
  (code-emit l0 (sdiv l1))
  (ret))

(code comp-var
  (parse-symbol l1 l2)
  (set l3 (cc-next-frame-offset x5))
  (add l3 8)
  (set (cc-next-frame-offset x5) l3)
  (exp-sym-define l2 exp-sym-type-local l3)
  (ret))

(code comp-expr-table
  (8 comp-begin)
  (8 syntax)     ; 1 label
  (8 syntax)     ; 2 goto
  (8 comp-if)    ; 3
  (8 comp-unop)  ; 4
  (8 comp-polop) ; 5
  (8 comp-var)   ; 6
  comp-expr-table-end)

(def comp-expr-table-size (>> (- comp-expr-table-end comp-expr-table) 3))

(code comp-expr
  ;; l0 - codeptr
  ;; l1 - exp
  (assert-type l1 exp-type-number .not-number)
  (set l2 (exp-num-val l1))
  (code-emit l0 (set l0 0xFFFFFFFFFFFFFFFF) l2)
  (ret)
.not-number
  (assert-type l1 exp-type-symbol .not-symbol)
  (set l2 (exp-sym-type l1))
  (cmp l2 exp-sym-type-local)
  (jne error-undef)
  (set l2 (exp-sym-val l1))
  (neg l2)
  (code-emit l0 (set l0 (u64 x1 0xFFFF)) l2)
  (ret)
.not-symbol
  (parse-num l1 l2 comp-expr-table-size)
  (set l3 comp-expr-table)
  (set l3 (u64 l3 l2))
  (code-check l0)
  (jmp l3))

(code comp-top-def
  (parse-exp l1 l2)
  (parse-symbol l2 l3)
  (set l4 -8)
.arg-next
  (cmp l2 0)
  (je .arg-done)
  (parse-symbol l2 l3)
  (exp-sym-define l3 exp-sym-type-local l4)
  (sub l4 8)
  (jmp .arg-next)
.arg-done
  (set (cc-next-frame-offset x5) 0)
  (parse-exp l1 l2)
  (parse-eol l1)
  (set l1 l2)
  (code-emit l0 (set x1 sp))
  (push l0)
  (code-emit l0 (sub sp 0x0FFFF) 0)
  (call comp-expr)
  (code-emit l0 (set sp x1))
  (code-emit l0 (ret))
  (pop l2)
  (set l3 (cc-next-frame-offset x5))
  (code-emit l2 (sub sp 0xFFFF) l3)
  (ret))

(code comp-top-table
  (8 comp-top-def)
  comp-top-table-end)

(def comp-top-table-size (>> (- comp-top-table-end comp-top-table) 3))

(code comp-top
  ;; l0 - codeptr
  ;; l1 - exp
  (parse-num l1 l2 comp-top-table-size)
  (set l3 comp-top-table)
  (set l3 (u64 l3 l2))
  (code-check l0)
  (jmp l3))

;; Main

(data
  fbuf (sizeof file-buffer)
  cc (sizeof compiler-context))

(code main
  (let x5 (compiler-context cc))
  (call exp-init)
  (set x1 fbuf)
  (set l0 x1)
  (let l1 (u8 .boot-filename))
  (call file-open)
  (call code-init)
  (set x0 l0)
  (set l0 x1)
  (call exp-read)
  (set l1 l0)
  (set l0 x0)
  (call comp-top)
  (set l0 3)
  (push l0)
  (set l0 2)
  (push l0)
  (set l0 1)
  (push l0)
  (set l0 (cc-codebuf x5))
  (call l0)
  (jmp sys-exit)
.boot-filename
  (1 "boot.z1" 0))
