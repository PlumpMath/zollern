;;
;; Z1 -- bootstrapping
;;

;; This program in the Z0 language implements a primitive programming
;; system.
;;
;; (def (foo (a int32)
;;           (b (ptr FooData))
;;      int32
;;   ..)
;;
;; (def x (array int32 100) 12)
;;
;; (struct FooData
;;   (link (ptr FooData))
;;   (val  float64))

;;; ASCII

(const ascii-space       32)
(const ascii-tab          9)
(const ascii-lf          10)
(const ascii-open-paren  40)
(const ascii-close-paren 41)
(const ascii-dash        45)
(const ascii-0           48)
(const ascii-9           57)
(const ascii-semicolon   59)
(const ascii-a           97)

;;; String utilities

(fun (strlen s)
  (var l 0)
again
  (goto done (not (b@ s l)))
  (= l (+ l 1))
  (goto again)
done
  (return l))

(fun (strcpy dst src)
  (var b)
again
  (= b (b@ src))
  (b@= dst b)
  (= src (+ src 1))
  (= dst (+ dst 1))
  (goto again b))

(fun (strhash str)
  (var h 0)
  (var b)
again
  (= b (b@ str))
  (goto done (not b))
  (= h (^ (* h 33) b))
  (= str (+ str 1))
  (goto again)
done
  (return h))

(fun (strcmp a b)
  (var aa)
  (var bb)
again
  (= aa (b@ a))
  (= bb (b@ b))
  (goto done (not (== aa bb)))
  (= a (+ a 1))
  (= b (+ b 1))
  (goto again aa)
done
  (return (- bb aa)))

(fun (streq a b)
  (return (== (strcmp a b) 0)))

(fun (strtoint str)
  ;; XXX - most negative num
  (var b)
  (var i 0)
  (var s 1)
  (= b (b@ str))
  (goto positive (!= b ascii-dash))
  (= str (+ str 1))
  (= b (b@ str))
  (= s -1)
positive
again
  (goto done (not b))
  (= i (+ (* 10 i) (- b ascii-0)))
  (= str (+ str 1))
  (= b (b@ str))
  (goto again)
done
  (return (* s i)))

;;; Simple output

(fun (out-chars buf len)
  (syscall 1 2 buf len))

(mem out-buf 40)

(fun (out-char ch)
  (b@= out-buf ch)
  (out-chars out-buf 1))

(fun (out-nibble n)
  (goto hex (> n 9))
  (out-char (+ n ascii-0))
  (return)
hex
  (out-char (+ n ascii-a -10)))

(fun (out-byte b)
  (var hi (/ b 16))
  (var lo (- b (* hi 16)))
  (out-nibble hi)
  (out-nibble lo))

(fun (out-str s)
  (out-chars s (strlen s)))

(fun (out-nl)
  (out-char 10))

(fun (out-num i)
  ;; XXX - most negative num
  (var p out-buf)
  (var b out-buf)
  (var t)
  (goto positive (>= i 0))
  (out-char ascii-dash)
  (= i (- i))
positive
next-digit
  (b@= p (+ (% i 10) 48))
  (= p (+ p 1))
  (= i (/ i 10))
  (goto next-digit i)
  (b@= p 0)
reverse-next
  (= p (- p 1))
  (= t (b@ b))
  (b@= b (b@ p))
  (b@= p t)
  (= b (+ b 1))
  (goto reverse-next (> p b))
  (out-str out-buf))

;;; Debugging

(fun (pk-num label num)
  (out-str label)
  (out-str ": ")
  (out-num num)
  (out-nl)
  (return num))

(fun (pk-str label str)
  (out-str label)
  (out-str ": ")
  (out-str str)
  (out-nl)
  (return str))

(fun (pk label)
  (out-str label)
  (out-nl))

;;; Aborting

(fun (abort)
  (syscall 60 1))

(fun (abort-if-not cond)
  (goto out cond)
  (abort)
out)

;;; Lists

(const off-type 0)
(const type-pair 0)
(const type-sym  1)
(const type-inum 2)
(const type-str  3)
(const type-spec 4)

(const exp-size 4096)
(mem exp-pool exp-size)
(var exp-ptr)

(var exp-nil-obj)
(var exp-eof-obj)

(fun (init-exp)
  (= exp-ptr exp-pool)
  (= exp-nil-obj (exp-spec))
  (= exp-eof-obj (exp-spec)))

(fun (exp-alloc size)
  (var res exp-ptr)
  (= exp-ptr (+ exp-ptr size))
  (abort-if-not (< exp-ptr (+ exp-pool exp-size)))
  (return res))

(const size-spec 8)

(fun (exp-spec)
  (var p (exp-alloc size-spec))
  (@= p off-type type-spec)
  (return p))

(fun (exp-nil)
  (return exp-nil-obj))

(fun (exp-is-nil e)
  (return (== e exp-nil-obj)))

(fun (exp-eof)
  (return exp-eof-obj))

(fun (exp-is-eof e)
  (return (== e exp-eof-obj)))

(const off-pair-first  8)
(const off-pair-rest  16)
(const size-pair      24)

(fun (exp-pair first rest)
  (var p (exp-alloc size-pair))
  (@= p off-type type-pair)
  (@= p off-pair-first first)
  (@= p off-pair-rest rest)
  (return p))

(fun (exp-is-pair e)
  (return (== (@ e off-type) type-pair)))

(fun (exp-first e)
  (return (@ e off-pair-first)))

(fun (exp-rest e)
  (return (@ e off-pair-rest)))

(fun (set-exp-rest e r)
  (@= e off-pair-rest r))

(const off-inum-val  8)
(const size-inum    16)

(fun (exp-inum val)
  (var p (exp-alloc size-inum))
  (@= p off-type type-inum)
  (@= p off-inum-val val)
  (return p))

(fun (exp-is-inum e)
  (return (== (@ e off-type) type-inum)))

(fun (exp-inum-val e)
  (return (@ e off-inum-val)))

(const exp-symtab-size 1021)
(mem exp-symtab (* exp-symtab-size 8))

(const off-sym-link 8)
(const size-sym    16)

(fun (exp-sym name)
  (var h (% (strhash name) exp-symtab-size))
  (var b (@ exp-symtab (* h 8)))
  (var s b)
again
  (goto not-found (not s))
  (goto found (streq name (exp-sym-name s)))
  (= s (exp-sym-link s))
  (goto again)
not-found
  (= s (exp-alloc (+ size-sym (strlen name) 1)))
  (strcpy (+ s size-sym) name)
  (@= s off-type type-sym)
  (@= s off-sym-link b)
  (@= exp-symtab (* h 8) s)
found
  (return s))

(fun (exp-is-sym e)
  (return (== (@ e off-type) type-sym)))

(fun (exp-sym-name e)
  (return (+ e size-sym)))

(fun (exp-sym-link e)
  (return (@ e off-sym-link)))

(const size-string 8)

(fun (exp-string str)
  (var p (exp-alloc (+ size-string (strlen str) 1)))
  (strcpy (+ p size-string) str)
  (@= p off-type type-str)
  (return p))

(fun (exp-is-string e)
  (return (== (@ e off-type) type-str)))

(fun (exp-string-chars e)
  (return (+ e size-string)))

(fun (exp-write e)
  (var need-space 0)
  (goto list (exp-is-pair e))
  (goto not-list (not (exp-is-nil e)))
list
  (out-str "(")
list-next
  (goto list-end (not (exp-is-pair e)))
  (goto list-no-space (not need-space))
  (out-str " ")
list-no-space
  (exp-write (exp-first e))
  (= need-space 1)
  (= e (exp-rest e))
  (goto list-next)
list-end
  (goto list-end-nil (exp-is-nil e))
  (out-str " . ")
  (exp-write e)
list-end-nil
  (out-str ")")
  (return)
not-list
  (goto not-inum (not (exp-is-inum e)))
  (out-num (exp-inum-val e))
  (return)
not-inum
  (goto not-string (not (exp-is-string e)))
  (out-str "\"")
  (out-str (exp-string-chars e))
  (out-str "\"")
  (return)
not-string
  (goto not-sym (not (exp-is-sym e)))
  (out-str (exp-sym-name e))
  (return)
not-sym
  (out-str "<???>"))

;;; Input

;; The bootstrap compiler only reads from stdin, with a simple buffer.

(const input-bufsize 1024)
(const input-eof -1)

(mem input-buf input-bufsize)
(var input-cur)
(var input-end)

(fun (input-fillbuf)
  (var n (syscall 0 0 input-buf input-bufsize))
  (abort-if-not (>= n 0))
  (= input-cur input-buf)
  (= input-end (+ input-buf n)))

(fun (input)
  (var r)
  (goto non-empty (< input-cur input-end))
  (input-fillbuf)
  (goto non-empty (< input-cur input-end))
  (return input-eof)
non-empty
  (= r (b@ input-cur))
  (= input-cur (+ input-cur 1))
  (return r))

(fun (input-undo)
  (goto empty-buf (== input-cur input-buf))
  (= input-cur (- input-cur 1))
empty-buf)

;;; Tokenization

(const token-eof -1)
(const token-symbol 0)
(const token-punct 1)
(const token-inum 2)
(const token-dnum 3)
(const token-string 4)

(const token-max 512)
(mem token token-max)
(var token-kind)

(fun (skip-whitespace)
  (var c)
again
  (= c (input))
  (goto again (== c ascii-space))
  (goto again (== c ascii-tab))
  (goto again (== c ascii-lf))
  (goto comment (== c ascii-semicolon))
  (input-undo)
  (return)
comment
  (= c (input))
  (goto again (== c ascii-lf))
  (goto comment))

(fun (read-token)
  (var c)
  (var t 0)
  (var symlike-kind token-inum)
  (skip-whitespace)
  (= c (input))
  (goto eof (== c input-eof))
  (goto punct (== c ascii-open-paren))
  (goto punct (== c ascii-close-paren))
  (goto symbol)
eof
  (= token-kind token-eof)
  (return)
punct
  (b@= token t c)
  (b@= token (+ t 1) 0)
  (= token-kind token-punct)
  (return)
symbol
  (goto symbol-done (== c input-eof))
  (goto symbol-done (== c ascii-space))
  (goto symbol-done (== c ascii-tab))
  (goto symbol-done (== c ascii-lf))
  (goto symbol-done (== c ascii-semicolon))
  (goto symbol-done (== c ascii-open-paren))
  (goto symbol-done (== c ascii-close-paren))
  (goto check-sign (< c ascii-0))
  (goto is-number-char (<= c ascii-9))
check-sign
  (goto is-not-number-char (!= t 0))
  (goto is-number-char (== c ascii-dash))
is-not-number-char
  (= symlike-kind token-symbol)
is-number-char
  (b@= token t c)
  (= t (+ t 1))
  (= c (input))
  (goto symbol)
symbol-done
  (input-undo)
  (b@= token t 0)
  (= token-kind symlike-kind)
  (return))

;;; Reading lists

(fun (syntax-error)
  (out-str "syntax error\n")
  (abort))

(fun (reverse e)
  (var r (exp-nil))
  (var n)
again
  (goto done (not (exp-is-pair e)))
  (= n (exp-rest e))
  (set-exp-rest e r)
  (= r e)
  (= e n)
  (goto again)
done
  (return r))

(fun (exp-read-1)
  (var e)
  (goto not-eof (!= token-kind token-eof))
  (return (exp-eof))
not-eof
  (goto not-sym (!= token-kind token-symbol))
  (return (exp-sym token))
not-sym
  (goto not-inum (!= token-kind token-inum))
  (return (exp-inum (strtoint token)))
not-inum
  (goto not-punct (!= token-kind token-punct))
  (goto not-punct (!= (b@ token) ascii-open-paren))
  (= e (exp-nil))
list-again
  (read-token)
  (goto syntax-error (== token-kind token-eof))
  (goto list-append (!= token-kind token-punct))
  (goto list-append (!= (b@ token) ascii-close-paren))
  (return (reverse e))
list-append
  (= e (exp-pair (exp-read-1) e))
  (goto list-again)
not-punct
syntax-error
  (syntax-error))

(fun (exp-read)
  (read-token)
  (return (exp-read-1)))

;;; Emitting code

(const code-size 1024)
(mem code code-size)
(var code-ptr)

(fun (init-code)
  (= code-ptr code))

(fun (emit-8 b)
  (abort-if-not (< code-ptr (+ code code-size)))
  (b@= code-ptr b)
  (= code-ptr (+ code-ptr 1)))

(fun (emit-16 w)
  (emit-8 w)
  (emit-8 (>> w 8)))

(fun (emit-32 q)
  (emit-16 q)
  (emit-16 (>> q 16)))

(fun (emit-64 t)
  (emit-32 t)
  (emit-32 (>> t 32)))

(fun (emit-ret)
  (emit-8 0xC3))

;;; Main

(fun (main)
  (var e)
  (init-exp)
again
  (= e (exp-read))
  (goto done (exp-is-eof e))
  (exp-write e)
  (out-nl)
  (goto again)
done)
