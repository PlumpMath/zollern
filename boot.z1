;; A macro for defining primitives.
;;
;; We have to write this without any convenience helpers...
;;
;; (defprim NAME A)
;; =>
;; (0
;;   (1 ($nn form) ($prim-1 form A))
;;   (2 NAME 0 $nn))
;;
;; (defprim NAME A B)
;; =>
;; (0
;;   (1 ($nn form) ($prim-2 form A B))
;;   (2 NAME 0 $nn))

(1 ($prim-1 form a)
   (comp:make-pair
    (comp:make-number a)
    (comp:rest form)))

(1 ($prim-2 form a b)
   (comp:make-pair
    (comp:make-number a)
    (comp:make-pair
     (comp:make-number b)
     (comp:rest form))))

(1 ($defprim form)
   (0
    (9 gensym) (10 gensym (comp:gensym))
    (9 name-cell) (10 name-cell (comp:rest form))
    (9 a-cell) (10 a-cell (comp:rest name-cell))
    (9 b-cell) (10 b-cell (comp:rest a-cell))
    (comp:make-pair
     (comp:make-number 0)
     (comp:make-pair
      (comp:make-pair
       (comp:make-number 1)
       (comp:make-pair
        (comp:make-pair
         gensym
         (comp:make-pair
          (comp:intern "form")
          0)))
       (comp:make-pair
        (comp:make-pair
         (5 b-cell (comp:intern "$prim-2") (comp:intern "$prim-1"))
         (comp:make-pair
          (comp:intern "form")
          (comp:make-pair
           (comp:first a-cell)
           (5 b-cell
              (comp:make-pair
               (comp:first b-cell)
               0)
              0))))
        0))
      (comp:make-pair
       (comp:make-pair
        (comp:make-number 2)
        (comp:make-pair
         (comp:first name-cell)
         (comp:make-pair
          (comp:make-number 0)
          (comp:make-pair
           gensym
           0)))
        0)
       0)))))
(2 defprim 0 $defprim)

;; And another similar macro for defining primitive setters.
;;
;; (defprim-setter NAME A)
;; =>
;; (0
;;   (1 ($nn form val) ($prim-set form val A))
;;   (2 NAME 2 $nn))

(1 ($prim-set form val a)
   (comp:make-pair
    (comp:make-number 13)
    (comp:make-pair
     (comp:make-number a)
     (comp:make-pair
      (comp:first (comp:rest form))
      (comp:make-pair
       val
       0)))))

(1 ($defprim-set form)
   (0
    (9 gensym) (10 gensym (comp:gensym))
    (9 name-cell) (10 name-cell (comp:rest form))
    (9 a-cell) (10 a-cell (comp:rest name-cell))
    (comp:make-pair
     (comp:make-number 0)
     (comp:make-pair
      (comp:make-pair
       (comp:make-number 1)
       (comp:make-pair
        (comp:make-pair
         gensym
         (comp:make-pair
          (comp:intern "form")
          (comp:make-pair
           (comp:intern "val")
           0))))
       (comp:make-pair
        (comp:make-pair
         (comp:intern "$prim-set")
         (comp:make-pair
          (comp:intern "form")
          (comp:make-pair
           (comp:intern "val")
           (comp:make-pair
            (comp:first a-cell)
            0))))
        0))
      (comp:make-pair
       (comp:make-pair
        (comp:make-number 2)
        (comp:make-pair
         (comp:first name-cell)
         (comp:make-pair
          (comp:make-number 2)
          (comp:make-pair
           gensym
           0)))
        0)
       0)))))
(2 defprim-set 0 $defprim-set)

;; Primitives
;;
;; Some primitives are okay for direct use, but some need to be
;; wrapped in nicer clothing, like 'fun' and 'var'.

(defprim begin      0)
(defprim prim-fun   1)
(defprim prim-mac   2)
(defprim label      3)
(defprim goto       4)
(defprim prim-if    5)
(defprim prim-var   9)
(defprim set       10)
(defprim loc       11)

(defprim  u8     12 0)
(defprim u16     12 1)
(defprim u32     12 2)
(defprim u64     12 3)
(defprim  s8     12 4)
(defprim s16     12 5)
(defprim s32     12 6)
(defprim s64     12 7)

(defprim-set  u8 0)
(defprim-set u16 1)
(defprim-set u32 2)
(defprim-set u64 3)
(defprim-set  s8 4)
(defprim-set s16 5)
(defprim-set s32 6)
(defprim-set s64 7)

(defprim prim-neg   6 0)
(defprim not        6 1)

(defprim ==         7 0)
(defprim !=         7 1)
(defprim <          7 2)
(defprim <=         7 3)
(defprim >          7 4)
(defprim >=         7 5)

(defprim +          8 0)
(defprim -          8 1)
(defprim *          8 2)
(defprim /          8 3)

;; Syntax templates, aka quasi-quote

(prim-fun ($rcons* n tail)
  (begin
    (prim-var result)
    (prim-var next)
    (set result tail)
    (set next (+ (loc tail) 8))
    (label loop)
    (prim-if (== n 0)
             (goto done)
             12)
    (set result (comp:make-pair (u64 next) result))
    (set next (+ next 8))
    (set n (- n 1))
    (goto loop)
    (label done)
    result))

(prim-fun (expand-template form meta dot)
  (begin
    (prim-var tail)
    (prim-var result)
    (prim-var result-length)
    (prim-var first)
    (prim-var type)
    (prim-var arg)
    (set tail (comp:make-number 0))
    (set result 0)
    (set result-length 0)
    (label loop)
    (prim-if form
             (begin)
             (goto done))
    (set first (comp:first form))
    (set type (comp:type first))
    (set arg 0)
    (prim-if (== type 0) ;; pair
             (set arg (expand-template first meta dot))
             (begin))
    (prim-if (== type 1) ;; symbol
             (prim-if (== first meta)
                      (begin
                        (comp:first (comp:rest form))
                        (goto out))
                      (prim-if (== first dot)
                               (begin
                                 (set tail (expand-template (comp:first (comp:rest form))
                                                            meta dot))
                                 (goto done))
                               ;; `(comp:intern ,(comp:make-string (comp:symbol-name first))
                               (set arg (comp:make-pair
                                         (comp:intern "comp:intern")
                                         (comp:make-pair
                                          (comp:make-string (comp:symbol-name first))
                                          0)))))
             (begin))
    (prim-if (== type 2) ;; string
             (set arg (comp:make-pair
                       (comp:intern "comp:make-string")
                       (comp:make-pair
                        first
                        0)))
             (begin))
    (prim-if (== type 3) ;; number
             (set arg (comp:make-pair
                       (comp:intern "comp:make-number")
                       (comp:make-pair
                        first
                        0)))
             (begin))
    (prim-if arg
             (begin
               (set result (comp:make-pair arg result))
               (set result-length (+ result-length 1)))
             (begin))
    (set form (comp:rest form))
    (goto loop)
    (label done)
    (comp:make-pair
     (comp:intern "$rcons*")
     (comp:make-pair
      (comp:make-number result-length)
      (comp:make-pair
       tail
       result)))
    (label out)))

(prim-fun ($syntax-expand form)
          (expand-template (comp:first (comp:rest form))
                           (comp:intern "meta") (comp:intern ".")))
(prim-mac syntax-expand 0 $syntax-expand)

;; Enhanced versions of some primitives

;; (var NAME)
;; =>
;; (prim-var NAME)
;;
;; (var NAME INIT)
;; =>
;; (begin
;;  (prim-var NAME)
;;  (set NAME INIT))

(prim-fun ($var form)
  (begin
    (prim-var name)      (set name      (comp:first (comp:rest form)))
    (prim-var init-cell) (set init-cell (comp:rest (comp:rest form)))
    (prim-if init-cell
             (syntax-expand (begin (prim-var ?name)
                                   (set ?name ?(comp:first init-cell))))
             (syntax-expand (prim-var ?name)))))
(prim-mac var 0 $var)

;; (fun HEAD . BODY)
;; =>
;; (prim-fun HEAD (begin . BODY))

(prim-fun ($fun form)
  (begin
    (var head (comp:first (comp:rest form)))
    (var body (comp:rest (comp:rest form)))
    (syntax-expand
     (prim-fun ?head (begin . ?body)))))
(prim-mac fun 0 $fun)

;; (if COND THEN ELSE)
;; =>
;; (prim-if COND THEN ELSE)
;;
;; (if COND THEN)
;; =>
;; (prim-if COND THEN (begin))

(fun ($if form)
  (var cond (comp:first (comp:rest form)))
  (var then (comp:first (comp:rest (comp:rest form))))
  (var else-cell (comp:rest (comp:rest (comp:rest form))))
  (prim-if else-cell
           (syntax-expand (prim-if ?cond ?then ?(comp:first else-cell)))
           (syntax-expand (prim-if ?cond ?then (begin)))))
(prim-mac if 0 $if)

;; Main

(fun (fac n)
  (if (< n 2)
      n
      (* n (fac (- n 1)))))

(fun (main)
  (var m 5)
  (fac m))
