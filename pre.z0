;; Utilities

(def (seq ?f ?start ?inc)
  (begin))

(def (seq ?f ?start ?inc ?first . ?rest)
  (begin
    (?f ?first ?start)
    (seq ?f (+ ?start ?inc) ?inc . ?rest)))

(def (defenum . ?rest)
  (seq def 0 1 . ?rest))

(def (deftypedenum-from ?start ?type)
  (begin))

(def (deftypedenum-from ?start ?type ?member . ?rest)
  (begin
    (def ?member (?type ?start))
    (deftypedenum-from (+ ?start 1) ?type . ?rest)))

(def (deftypedenum ?type . ?members)
  (deftypedenum-from 0 ?type . ?members))

(def (<<<-accum ?accum)
  ?accum)

(def (<<<-accum ?accum ?val ?bits . ?rest)
  (<<<-accum (| (<< ?accum ?bits)
                (& ?val (- (<< 1 ?bits) 1)))
             . ?rest))

(def (<<< . ?rest)
  (<<<-accum 0 . ?rest))

;; Registers and calling convention
;;
;; Registerd l0-l8 must be saved by caller.  Registers x0-x5 and sp
;; must be saved by callee.  Arguments are passed in l0-l8.  Results
;; are returned in l0-l8.  Register sp is the stack pointer.

(deftypedenum reg
  l0  l1  l2  x0  sp  x1  l3  l4
  l5  l6  l7  l8  x2  x3  x4  x5)

;; Characters

(defenum
  ;; 0x00
  :nul :soh :stx :etx :eot :enq :ack :bel
  :bs  :ht  :nl  :vt  :np  :cr  :so  :si
  :dle :dc1 :dc2 :dc3 :dc4 :nak :syn :etb
  :can :em  :sub :esc :fs  :gs  :rs  :us

  ;; 0x20
  :spc :!   :dq  :#   :$   :%   :&   :sq
  :lp  :rp  :*   :+   :,   :-   :.   :/
  :0   :1   :2   :3   :4   :5   :6   :7
  :8   :9   ::   :sc  :<   :=   :>   :?

  ;; 0x40
  :@   :A   :B   :C   :D   :E   :F   :G
  :H   :I   :J   :K   :L   :M   :N   :O
  :P   :Q   :R   :S   :T   :U   :V   :W
  :X   :Y   :Z   :[   :bsl :]   :^   :_

  ;; 0x60
  :bt  :a   :b   :c   :d   :e   :f   :g
  :h   :i   :j   :k   :l   :m   :n   :o
  :p   :q   :r   :s   :t   :u   :v   :w
  :x   :y   :z   :{   :bar :}   :~   :del)

;; Fundamental types

(def (deftype ?name ?size ?min ?max)
  (def (sizeof ?name) ?size)
  (def (min ?name) ?min)
  (def (max ?name) ?max))

(def (is? ?type ?val)
  (&& (<= (min ?type) ?val) (<= ?val (max ?type))))

(deftype u8 1     0 0xFF)
(deftype s8 1 -0x80 0x7F)

(deftype u16 2       0 0xFFFF)
(deftype s16 2 -0x8000 0x7FFF)

(deftype u32 4           0 0xFFFFFFFF)
(deftype s32 4 -0x80000000 0x7FFFFFFF)

(deftype u64 8                   0 0xFFFFFFFFFFFFFFFF)
(deftype s64 8 -0x8000000000000000 0x7FFFFFFFFFFFFFFF)

;; Structs

(def (defstruct-at ?name ?off)
  (def (sizeof ?name) ?off))

(def (defstruct-at ?name ?off (?type ?field) . ?rest)
  (defstruct-at ?name ?off (?type ?field 1) . ?rest))

(def (defstruct-at ?name ?off (?type ?field ?length) . ?rest)
  (begin
    (def (?field ??ptr) (?type ??ptr ?off))
    (defstruct-at ?name (+ ?off (* (sizeof ?type) ?length)) . ?rest)))

(def (defstruct ?name . ?rest)
  (defstruct-at ?name 0 . ?rest))

;; Instructions

(def (rex ?w ?r ?x ?b)
  (<<< 4 4 ?w 1 ?r 1 ?x 1 ?b 1))

;; inserts the rex prefix in the right place

(def (rex-op ?rex (1 . ?ops))
  (1 ?rex . ?ops))

(def (rex-op ?rex (1 0x40 . ?ops))
  (1 ?rex . ?ops))

(def (rex-op ?rex (1 0x66 . ?ops))
  (1 0x66 ?rex . ?ops))

(def (rex-op 0x40 ?op)
  ?op)

(def (mod/rm ?mod ?r ?m)
  (<<< ?mod 2 ?r 3 ?m 3))

(def (sib ?scale ?index ?base)
  (<<< ?scale 2 ?index 3 ?base 3))

(def (log2 1) 0)
(def (log2 2) 1)
(def (log2 4) 2)
(def (log2 8) 3)

;; Instructions with both operands in a register.

(def (inst-rr ?w ?op ?a ?b)
  (rex-op (rex ?w (>> ?a 3) 0 (>> ?b 3)) ?op)
  (1 (mod/rm 3 ?a ?b)))

;; Instructions with one operand in a register and the other in
;; memory.  This also defines the syntax for addresses:
;;
;; (type (reg base))
;; (type (reg base) offset)
;; (type1 (type2 (reg base) offset2) offset1)
;; (type (reg base) scale (reg index))
;; (type (reg base) scale (reg index) offset)

(def (inst-rm ?w ?op ?reg ?type (?type2 ?base ?offset2) ?offset1)
  (inst-rm ?w ?op ?reg ?type ?base (+ ?offset2 ?offset1)))

(def (inst-rm ?w ?op ?reg ?type ?addr)
  (inst-rm.pcrel ?w ?op ?reg ?addr))

(def (inst-rm ?w ?op ?reg ?type (reg ?base))
  (inst-rm ?w ?op ?reg ?type (reg ?base) 0))

(def (inst-rm ?w ?op ?reg ?type (reg ?base) ?offset)
  (inst-rm ?w ?op ?reg ?type (reg ?base) 0 (reg 0) ?offset))

(def (inst-rm ?w ?op ?reg ?type (reg ?base) (reg ?index))
  (inst-rm ?w ?op ?reg ?type (reg ?base) (sizeof ?type) (reg ?index) 0))

(def (inst-rm ?w ?op ?reg ?type (reg ?base) (reg ?index) ?offset)
  (inst-rm ?w ?op ?reg ?type (reg ?base) (sizeof ?type) (reg ?index) ?offset))

(def (inst-rm ?w ?op ?reg ?type (reg ?base) ?scale (reg ?index))
  (inst-rm ?w ?op ?reg ?type (reg ?base) ?scale (reg ?index) 0))

(def (inst-rm ?w ?op ?reg ?type (reg ?base) ?scale (reg ?index) ?offset)
  (sel (== ?index 4) (error "sp can't be index")
                     (begin))
  (sel (== ?scale 0)
       (sel (== (& ?base 7) 4)
            (inst-rm.rbiso ?w ?op ?reg ?base 4 1 ?offset)
            (inst-rm.rbo ?w ?op ?reg ?base ?offset))
       (inst-rm.rbiso ?w ?op ?reg ?base ?index ?scale ?offset)))

(def (inst-rm.rbo ?w ?op ?reg ?base ?offset)
  (rex-op (rex ?w (>> ?reg 3) 0 (>> ?base 3))
          ?op)
  (sel (&& (== ?offset 0) (!= (& ?base 7) 5))
       (begin
         (1 (mod/rm 0 ?reg ?base)))
       (is? s8 ?offset)
       (begin
         (1 (mod/rm 1 ?reg ?base) ?offset))
       (is? s32 ?offset)
       (begin
         (1 (mod/rm 2 ?reg ?base))
         (4 ?offset))))

(def (inst-rm.rbiso ?w ?op ?reg ?base ?index ?scale ?offset)
  (rex-op (rex ?w (>> ?reg 3) (>> ?index 3) (>> ?base 3))
          ?op)
  (sel (&& (== ?offset 0) (!= (& ?base 7) 5))
       (begin
         (1 (mod/rm 0 ?reg 4)
            (sib (log2 ?scale) ?index ?base)))
       (is? s8 ?offset)
       (begin
         (1 (mod/rm 1 ?reg 4)
            (sib (log2 ?scale) ?index ?base)
            ?offset))
       (is? s32 ?offset)
       (begin
         (1 (mod/rm 2 ?reg 4)
            (sib (log2 ?scale) ?index ?base))
         (4 ?offset))))

(def (inst-rm.pcrel ?w ?op ?reg ?addr)
  (rex-op (rex ?w (>> ?reg 3) 0 0) ?op)
  (1 (mod/rm 0 ?reg 5))
  (-4 ?addr))

;; Instructions with one operand in a register, and the other as an
;; immediate

(def (inst-ri8 ?w ?x ?op ?reg ?val)
  (rex-op (rex ?w (>> ?x 3) 0 (>> ?reg 3)) ?op)
  (1 (mod/rm 3 ?x ?reg))
  (1 ?val))

(def (inst-ri32 ?w ?x ?op ?reg ?val)
  (rex-op (rex ?w (>> ?x 3) 0 (>> ?reg 3)) ?op)
  (1 (mod/rm 3 ?x ?reg))
  (4 ?val))

;; Convenience macros for defining instructions.

(def (def-inst (?name . ?rest))
  (begin))

(def (def-inst (?name reg _) (?type ?w . ?op) . ?rest)
  (begin
    (def (?name (reg ??dst) (?type . ??addr))
      (inst-rm ?w (1 . ?op) ??dst ?type . ??addr))
    (def-inst (?name reg _) . ?rest)))

(def (def-inst (?name reg _) (reg ?w . ?op) . ?rest)
  (begin
    (def (?name (reg ??dst) (reg ??src))
      (inst-rr ?w (1 . ?op) ??src ??dst))
    (def-inst (?name reg _) . ?rest)))

(def (def-inst (?name _ reg) (?type ?w . ?op) . ?rest)
  (begin
    (def (?name  (?type . ??addr) (reg ??src))
      (inst-rm ?w (1 . ?op) ??src ?type . ??addr))
    (def-inst (?name _ reg) . ?rest)))

(def (def-inst (?name _ reg) (reg ?w . ?op) . ?rest)
  (begin
    (def (?name (reg ??dst) (reg ??src))
      (inst-rr ?w (1 . ?op) ??dst ??src))
    (def-inst (?name reg _) . ?rest)))

(def (def-inst (?name reg imm) (s32 ?w32 ?x32 . ?op32))
  (def (?name (reg ??dst) ??val)
    (sel (! (is? s32 ??val))   (error)
                               (inst-ri32 ?w32 ?x32 (1 . ?op32) ??dst ??val))))

(def (def-inst (?name reg imm) (s8 ?w8 ?x8 . ?op8) (s32 ?w32 ?x32 . ?op32))
  (def (?name (reg ??dst) ??val)
    (sel (is? s8 ??val)        (inst-ri8 ?w8 ?x8 (1 . ?op8) ??dst ??val)
         (! (is? s32 ??val))   (error)
                               (inst-ri32 ?w32 ?x32 (1 . ?op32) ??dst ??val))))

;; Defining instructions, second try
;;
;; Use:
;;
;; (def-inst set
;;   ((reg reg) (w 1) (op ...))
;;   ((reg u8)  (w 0) (op ...)))
;;
;; Because of how macro expansion works, immediates must come first.

(def (def-inst2 ?name . ?rest)
  (def-inst-0 ?name . ?rest))

;; Immediates

(def (inst2-ri ?size ?dst ?val (w ?w) (x ?x) (op . ?op))
  (rex-op (rex ?w (>> ?x 3) 0 (>> ?dst 3)) (1 . ?op))
  (1 (mod/rm 3 ?x ?dst))
  (?size ?val))

(def (inst2-ri ?size ?dst ?val (w ?w) (x dst) (op . ?op))
  (inst2-ri ?size ?dst ?val (w ?w) (x ?dst) (op . ?op)))

(def (inst2-ri ?size ?dst ?val (w ?w) (op/dst ?op))
  (1 (rex 1 0 0 (>> ?dst 3)) (+ ?op (& ?dst 7)))
  (?size ?val))

(def (def-inst-0 ?name . ?rest)
  (def-inst-1 ?name . ?rest))

(def (def-inst-0 ?name
       ((?type i8) . ?op)
       . ?rest)
  (def (?name (?type . ??addr) ??val)
       (inst2-rm ?type 0 ??addr . ?op)
       (1 ??val))
  (def-inst-0 ?name . ?rest))

(def (def-inst-0 ?name
       ((?type i32) . ?op)
       . ?rest)
  (def (?name (?type . ??addr) ??val)
       (inst2-rm ?type 0 ??addr . ?op)
       (4 ??val))
  (def-inst-0 ?name . ?rest))

(def (def-inst-0 ?name
       ((reg i8) . ?op8)
       . ?rest)
  (def (?name (reg ??dst) ??val)
       (inst2-ri 1 ??dst ??val . ?op8))
  (def-inst-0 ?name . ?rest))

(def (def-inst-0 ?name
       ((reg i8) . ?op8)
       ((reg i32) . ?op32)
       . ?rest)
  (def (?name (reg ??dst) ??val)
       (sel (is? s8  ??val) (inst2-ri 1 ??dst ??val . ?op8)
            (is? s32 ??val) (inst2-ri 4 ??dst ??val . ?op32)))
  (def-inst-0 ?name . ?rest))

(def (def-inst-0 ?name
       ((reg i32) . ?op32)
       . ?rest)
  (def (?name (reg ??dst) ??val)
       (inst2-ri 4 ??dst ??val . ?op32))
  (def-inst-0 ?name . ?rest))

(def (def-inst-0 ?name
       ((reg i32) . ?op32)
       ((reg i64) . ?op64)
       . ?rest)
  (def (?name (reg ??dst) ??val)
       (sel (is? s32 ??val) (inst2-ri 4 ??dst ??val . ?op32)
                            (inst2-ri 8 ??dst ??val . ?op64)))
  (def-inst-0 ?name . ?rest))

;; Rest

(def (inst2-rr ?dst ?src (w ?w) (op . ?op))
  (rex-op (rex ?w (>> ?src 3) 0 (>> ?dst 3)) (1 . ?op))
  (1 (mod/rm 3 ?src ?dst)))

(def (inst2-rr ?dst ?src (w ?w) (op . ?op) (regs-reversed))
  (inst2-rr ?src ?dst (w ?w) (op . ?op)))

(def (inst2-rm ?type ?reg ?addr (w ?w) (op . ?op))
  (inst-rm ?w (1 . ?op) ?reg ?type . ?addr))

(def (def-inst-1 ?name
       ((reg ?type) . ?op)
       . ?rest)
  (def (?name (reg ??dst) (?type . ??addr))
       (inst2-rm ?type ??dst ??addr . ?op))
  (def-inst-1 ?name . ?rest))

(def (def-inst-1 ?name
       ((?type reg) . ?op)
       . ?rest)
  (def (?name (?type . ??addr) (reg ??src))
       (inst2-rm ?type ??src ??addr . ?op))
  (def-inst-1 ?name . ?rest))

(def (def-inst-1 ?name
       ((reg mem) . ?op)
       . ?rest)
  (def (?name (reg ??dst) (??type . ??addr))
       (inst2-rm ??type ??dst ??addr . ?op))
  (def-inst-1 ?name . ?rest))

(def (def-inst-1 ?name
       ((reg reg) . ?op)
       . ?rest)
  (def (?name (reg ??dst) (reg ??src))
       (inst2-rr ??dst ??src . ?op))
  (def-inst-1 ?name . ?rest))

(def (def-inst-1 ?name
       ((reg)   (w ?w) (x ?x) (op . ?op))
       . ?rest)
  (def (?name (reg ??reg))
       (rex-op (rex ?w 0 0 (>> ??reg 3)) (1 . ?op))
       (1 (mod/rm 3 ?x ??reg)))
  (def-inst-1 ?name . ?rest))

(def (def-inst-1 ?name
       ((reg (reg ?fixed))   (w ?w) (x ?x) (op . ?op))
       . ?rest)
  (def (?name (reg ??reg) (reg ?fixed))
       (rex-op (rex ?w 0 0 (>> ??reg 3)) (1 . ?op))
       (1 (mod/rm 3 ?x ??reg)))
  (def-inst-1 ?name . ?rest))

(def (def-inst-1 ?name
       (()   (w ?w) (op . ?op))
       . ?rest)
  (def (?name)
       (rex-op (rex ?w 0 0 0) (1 . ?op)))
  (def-inst-1 ?name . ?rest))

(def (def-inst-1 ?name))

;; Setting registers

(def-inst2 set
  ((reg i32)   (w 1) (x 0) (op     0xC7))
  ((reg i64)   (w 1)       (op/dst 0xB8))
  (( u8  i8)   (w 0)       (op     0xC6))
  ((u32 i32)   (w 0)       (op     0xC7))
  ((u64 i32)   (w 1)       (op     0xC7))
  (( s8  i8)   (w 0)       (op     0xC6))
  ((s32 i32)   (w 0)       (op     0xC7))
  ((s64 i32)   (w 1)       (op     0xC7))
  ((reg reg)   (w 1)       (op     0x89))
  ((reg  u8)   (w 0)       (op     0x0F 0xB6))
  ((reg u16)   (w 0)       (op     0x0F 0xB7))
  ((reg u32)   (w 0)       (op     0x8B))
  ((reg u64)   (w 1)       (op     0x8B))
  ((reg  s8)   (w 1)       (op     0x0F 0xBE))
  ((reg s16)   (w 1)       (op     0x0F 0xBf))
  ((reg s32)   (w 1)       (op     0x63))
  ((reg s64)   (w 1)       (op     0x8B))
  (( u8 reg)   (w 0)       (op     0x40 0x88))
  ((u16 reg)   (w 0)       (op     0x66 0x89))
  ((u32 reg)   (w 0)       (op     0x89))
  ((u64 reg)   (w 1)       (op     0x89))
  (( s8 reg)   (w 0)       (op     0x40 0x88))
  ((s16 reg)   (w 0)       (op     0x66 0x89))
  ((s32 reg)   (w 0)       (op     0x89))
  ((s64 reg)   (w 1)       (op     0x89)))

(def-inst2 let
  ((reg mem)   (w 1) (op 0x8D)))

;; Addition

(def-inst2 add
  ((reg  i8)   (w 1) (x 0) (op 0x83))
  ((reg i32)   (w 1) (x 0) (op 0x81))
  ((reg reg)   (w 1)       (op 0x01))
  (( u8 reg)   (w 0)       (op 0x00))
  ((u16 reg)   (w 0)       (op 0x66 0x01))
  ((u32 reg)   (w 0)       (op 0x01))
  ((u64 reg)   (w 1)       (op 0x01))
  (( s8 reg)   (w 0)       (op 0x00))
  ((s16 reg)   (w 0)       (op 0x66 0x01))
  ((s32 reg)   (w 0)       (op 0x01))
  ((s64 reg)   (w 1)       (op 0x01)))

;; Subtraction

(def-inst2 sub
  ((reg  i8)   (w 1) (x 5) (op 0x83))
  ((reg i32)   (w 1) (x 5) (op 0x81))
  ((reg reg)   (w 1)       (op 0x29)))

;; Multiplication

(def-inst2 mul
  ((reg  i8)   (w 1) (x dst) (op 0x6B))
  ((reg i32)   (w 1) (x dst) (op 0x69))
  ((reg reg)   (w 1)         (op 0x0F 0xAF) (regs-reversed)))

(def-inst2 neg
  ((reg)       (w 1) (x 3)   (op 0xF7)))

(def-inst2 umul
  ((reg)       (w 1) (x 4)   (op 0xF7)))

(def-inst2 smul
  ((reg)       (w 1) (x 5)   (op 0xF7)))

;; Division

(def-inst2 sign-extend
  (()          (w 1) (op 0x99)))

(def-inst2 udiv
  ((reg)       (w 1) (x 6) (op 0xF7)))

(def-inst2 sdiv
  ((reg)       (w 1) (x 7) (op 0xF7)))

;; Bit twiddling

(def-inst2 and
  ((reg  i8)   (w 1) (x 4) (op 0x83))
  ((reg i32)   (w 1) (x 4) (op 0x81))
  ((reg reg)   (w 1)       (op 0x21)))

(def-inst2 or
  ((reg  i8)   (w 1) (x 1) (op 0x83))
  ((reg i32)   (w 1) (x 1) (op 0x81))
  ((reg reg)   (w 1)       (op 0x09)))

(def-inst2 xor
  ((reg  i8)   (w 1) (x 6) (op 0x83))
  ((reg i32)   (w 1) (x 6) (op 0x81))
  ((reg reg)   (w 1)       (op 0x31)))

(def-inst2 not
  ((reg)       (w 1) (x 2) (op 0xF7)))

;; Shifting

(def-inst2 shl
  ((reg i8)      (w 1) (x 4) (op 0xC1))
  ((reg)         (w 1) (x 4) (op 0xD1))
  ((reg (reg 1)) (w 1) (x 4) (op 0xD3)))

(def-inst2 shr
  ((reg i8)      (w 1) (x 5) (op 0xC1))
  ((reg)         (w 1) (x 5) (op 0xD1))
  ((reg (reg 1)) (w 1) (x 5) (op 0xD3)))

(def-inst2 sar
  ((reg i8)      (w 1) (x 7) (op 0xC1))
  ((reg)         (w 1) (x 7) (op 0xD1))
  ((reg (reg 1)) (w 1) (x 7) (op 0xD3)))

;; Comparison

(def-inst (cmp reg imm)
  (s8  1 7 0x83)
  (s32 1 7 0x81))

(def-inst (cmp reg _)
  (reg 1 0x39))

;; Stack

(def (push (reg ?reg))
  (rex-op (rex 0 0 0 (>> ?reg 3)) (1 (<<< 10 5 ?reg 3))))

(def (pop (reg ?reg))
  (rex-op (rex 0 0 0 (>> ?reg 3)) (1 (<<< 11 5 ?reg 3))))

;; Jumping and calling

(def (jmp ?addr)
  (1 0xe9) (-4 ?addr))

(def (jmp (reg ?reg))
  (rex-op (rex 0 0 0 (>> ?reg 3)) (1 0xFF (<<< 28 5 ?reg 3))))

(def (je ?addr)
  (1 0x0F 0x84) (-4 ?addr))

(def (jne ?addr)
  (1 0x0F 0x85) (-4 ?addr))

(def (jl ?addr)
  (1 0x0F 0x8C) (-4 ?addr))

(def (jle ?addr)
  (1 0x0F 0x8E) (-4 ?addr))

(def (jg ?addr)
  (1 0x0F 0x8F) (-4 ?addr))

(def (jge ?addr)
  (1 0x0F 0x8D) (-4 ?addr))

(def (ja ?addr)
  (1 0x0F 0x87) (-4 ?addr))

(def (jae ?addr)
  (1 0x0F 0x83) (-4 ?addr))

(def (jb ?addr)
  (1 0x0F 0x82) (-4 ?addr))

(def (jbe ?addr)
  (1 0x0F 0x86) (-4 ?addr))

(def (call ?addr)
  (1 0xe8) (-4 ?addr))

(def (call (reg ?reg))
  (rex-op (rex 0 0 0 (>> ?reg 3)) (1 0xFF (<<< 26 5 ?reg 3))))

(def (ret)
  (1 0xc3))

;; Local variables

(def (locals-1 ?offset ((?name ?type) . ?rest))
  (def ?name (?type x0 ?offset))
  (locals-1 (+ ?offset (sizeof ?type)) ?rest))

(def (locals-1 ?offset ())
  (push x0)
  (sub sp ?offset)
  (set x0 sp))

(def (locals ?vars)
  (locals-1 0 ?vars))

(def (end-locals)
  (set sp x0)
  (pop x0))

;; Init

(code start
  (jmp main))
