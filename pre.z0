;; Utilities

(def (seq ?f ?start ?inc)
  (begin))

(def (seq ?f ?start ?inc ?first . ?rest)
  (begin
    (?f ?first ?start)
    (seq ?f (+ ?start ?inc) ?inc . ?rest)))

(def (defenum . ?rest)
  (seq def 0 1 . ?rest))

(def (deftypedenum-from ?start ?type)
  (begin))

(def (deftypedenum-from ?start ?type ?member . ?rest)
  (begin
    (def ?member (?type ?start))
    (deftypedenum-from (+ ?start 1) ?type . ?rest)))

(def (deftypedenum ?type . ?members)
  (deftypedenum-from 0 ?type . ?members))

(def (<<<-accum ?accum)
  ?accum)

(def (<<<-accum ?accum ?val ?bits . ?rest)
  (<<<-accum (| (<< ?accum ?bits)
                (& ?val (- (<< 1 ?bits) 1)))
             . ?rest))

(def (<<< . ?rest)
  (<<<-accum 0 . ?rest))

;; Registers and calling convention
;;
;; Registerd l0-l8 must be saved by caller.  Registers x0-x5 and sp
;; must be saved by callee.  Arguments are passed in l0-l8.  Results
;; are returned in l0-l8.  Register sp is the stack pointer.

(deftypedenum reg
  l0  l1  l2  x0  sp  x1  l3  l4
  l5  l6  l7  l8  x2  x3  x4  x5)

;; Characters

(defenum
  ;; 0x00
  :nul :soh :stx :etx :eot :enq :ack :bel
  :bs  :ht  :nl  :vt  :np  :cr  :so  :si
  :dle :dc1 :dc2 :dc3 :dc4 :nak :syn :etb
  :can :em  :sub :esc :fs  :gs  :rs  :us

  ;; 0x20
  :spc :!   :dq  :#   :$   :%   :&   :sq
  :lp  :rp  :*   :+   :,   :-   :.   :/
  :0   :1   :2   :3   :4   :5   :6   :7
  :8   :9   ::   :sc  :<   :=   :>   :?

  ;; 0x40
  :@   :A   :B   :C   :D   :E   :F   :G
  :H   :I   :J   :K   :L   :M   :N   :O
  :P   :Q   :R   :S   :T   :U   :V   :W
  :X   :Y   :Z   :[   :bsl :]   :^   :_

  ;; 0x60
  :bt  :a   :b   :c   :d   :e   :f   :g
  :h   :i   :j   :k   :l   :m   :n   :o
  :p   :q   :r   :s   :t   :u   :v   :w
  :x   :y   :z   :{   :bar :}   :~   :del)

;; Fundamental types

(def (deftype ?name ?size ?min ?max)
  (def (sizeof ?name) ?size)
  (def (min ?name) ?min)
  (def (max ?name) ?max))

(def (is? ?type ?val)
  (&& (<= (min ?type) ?val) (<= ?val (max ?type))))

(deftype u8 1     0 0xFF)
(deftype s8 1 -0x80 0x7F)

(deftype u16 2       0 0xFFFF)
(deftype s16 2 -0x8000 0x7FFF)

(deftype u32 4           0 0xFFFFFFFF)
(deftype s32 4 -0x80000000 0x7FFFFFFF)

(deftype u64 8                   0 0xFFFFFFFFFFFFFFFF)
(deftype s64 8 -0x8000000000000000 0x7FFFFFFFFFFFFFFF)

;; Structs

(def (defstruct-at ?name ?off)
  (def (sizeof ?name) ?off))

(def (defstruct-at ?name ?off (?type ?field) . ?rest)
  (begin
    (def (?field ??ptr) (?type ??ptr ?off))
    (defstruct-at ?name (+ ?off (sizeof ?type)) . ?rest)))

(def (defstruct ?name . ?rest)
  (defstruct-at ?name 0 . ?rest))

;; Instructions

(def (rex ?w ?r ?x ?b)
  (<<< 4 4 ?w 1 ?r 1 ?x 1 ?b 1))

;; inserts the rex prefix in the right place

(def (rex-op ?rex (1 . ?ops))
  (1 ?rex . ?ops))

(def (rex-op ?rex (1 0x40 . ?ops))
  (1 ?rex . ?ops))

(def (rex-op ?rex (1 0x66 . ?ops))
  (1 0x66 ?rex . ?ops))

(def (rex-op 0x40 ?op)
  ?op)

(def (mod/rm ?mod ?r ?m)
  (<<< ?mod 2 ?r 3 ?m 3))

(def (sib ?scale ?index ?base)
  (<<< ?scale 2 ?index 3 ?base 3))

(def (log2 1) 0)
(def (log2 2) 1)
(def (log2 4) 2)
(def (log2 8) 3)

;; Instructions with both operands in a register.

(def (inst-rr ?w ?op ?a ?b)
  (rex-op (rex ?w (>> ?a 3) 0 (>> ?b 3)) ?op)
  (1 (mod/rm 3 ?a ?b)))

;; Instructions with one operand in a register and the other in
;; memory.  This also defines the syntax for addresses:
;;
;; (type (reg base))
;; (type (reg base) offset)
;; (type1 (type2 (reg base) offset2) offset1)
;; (type (reg base) scale (reg index))
;; (type (reg base) scale (reg index) offset)

(def (inst-rm ?w ?op ?reg ?type (?type2 ?base ?offset2) ?offset1)
  (inst-rm ?w ?op ?reg ?type ?base (+ ?offset2 ?offset1)))

(def (inst-rm ?w ?op ?reg ?type (reg ?base))
  (inst-rm ?w ?op ?reg ?type (reg ?base) 0))

(def (inst-rm ?w ?op ?reg ?type (reg ?base) ?offset)
  (inst-rm ?w ?op ?reg ?type (reg ?base) 0 (reg 0) ?offset))

(def (inst-rm ?w ?op ?reg ?type (reg ?base) (reg ?index))
  (inst-rm ?w ?op ?reg ?type (reg ?base) (sizeof ?type) (reg ?index) 0))

(def (inst-rm ?w ?op ?reg ?type (reg ?base) (reg ?index) ?offset)
  (inst-rm ?w ?op ?reg ?type (reg ?base) (sizeof ?type) (reg ?index) ?offset))

(def (inst-rm ?w ?op ?reg ?type (reg ?base) ?scale (reg ?index))
  (inst-rm ?w ?op ?reg ?type (reg ?base) ?scale (reg ?index) 0))

(def (inst-rm ?w ?op ?reg ?type (reg ?base) ?scale (reg ?index) ?offset)
  (sel (== ?index 4) (error "sp can't be index")
                     (begin))
  (sel (== ?scale 0)
       (sel (== (& ?base 7) 4)
            (inst-rm.rbiso ?w ?op ?reg ?base 4 1 ?offset)
            (inst-rm.rbo ?w ?op ?reg ?base ?offset))
       (inst-rm.rbiso ?w ?op ?reg ?base ?index ?scale ?offset)))

(def (inst-rm.rbo ?w ?op ?reg ?base ?offset)
  (rex-op (rex ?w (>> ?reg 3) 0 (>> ?base 3))
          ?op)
  (sel (&& (== ?offset 0) (!= (& ?base 7) 5))
       (begin
         (1 (mod/rm 0 ?reg ?base)))
       (is? s8 ?offset)
       (begin
         (1 (mod/rm 1 ?reg ?base) ?offset))
       (is? s32 ?offset)
       (begin
         (1 (mod/rm 2 ?reg ?base))
         (4 ?offset))))

(def (inst-rm.rbiso ?w ?op ?reg ?base ?index ?scale ?offset)
  (rex-op (rex ?w (>> ?reg 3) (>> ?index 3) (>> ?base 3))
          ?op)
  (sel (&& (== ?offset 0) (!= (& ?base 7) 5))
       (begin
         (1 (mod/rm 0 ?reg 4)
            (sib (log2 ?scale) ?index ?base)))
       (is? s8 ?offset)
       (begin
         (1 (mod/rm 1 ?reg 4)
            (sib (log2 ?scale) ?index ?base)
            ?offset))
       (is? s32 ?offset)
       (begin
         (1 (mod/rm 2 ?reg 4)
            (sib (log2 ?scale) ?index ?base))
         (4 ?offset))))

;; Instructions with one operand in a register, and the other as an
;; immediate

(def (inst-ri8 ?w ?x ?op ?reg ?val)
  (rex-op (rex ?w (>> ?x 3) 0 (>> ?reg 3)) ?op)
  (1 (mod/rm 3 ?x ?reg))
  (1 ?val))

(def (inst-ri32 ?w ?x ?op ?reg ?val)
  (rex-op (rex ?w (>> ?x 3) 0 (>> ?reg 3)) ?op)
  (1 (mod/rm 3 ?x ?reg))
  (4 ?val))

;; Convenience macros for defining instructions.

(def (def-inst (?name . ?rest))
  (begin))

(def (def-inst (?name reg _) (?type ?w . ?op) . ?rest)
  (begin
    (def (?name (reg ??dst) (?type . ??addr))
      (inst-rm ?w (1 . ?op) ??dst ?type . ??addr))
    (def-inst (?name reg _) . ?rest)))

(def (def-inst (?name reg _) (reg ?w . ?op) . ?rest)
  (begin
    (def (?name (reg ??dst) (reg ??src))
      (inst-rr ?w (1 . ?op) ??src ??dst))
    (def-inst (?name reg _) . ?rest)))

(def (def-inst (?name _ reg) (?type ?w . ?op) . ?rest)
  (begin
    (def (?name  (?type . ??addr) (reg ??src))
      (inst-rm ?w (1 . ?op) ??src ?type . ??addr))
    (def-inst (?name _ reg) . ?rest)))

(def (def-inst (?name _ reg) (reg ?w . ?op) . ?rest)
  (begin
    (def (?name (reg ??dst) (reg ??src))
      (inst-rr ?w (1 . ?op) ??dst ??src))
    (def-inst (?name reg _) . ?rest)))

(def (def-inst (?name reg imm) (s32 ?w32 ?x32 . ?op32))
  (def (?name (reg ??dst) ??val)
    (sel (! (is? s32 ??val))   (error)
                               (inst-ri32 ?w32 ?x32 (1 . ?op32) ??dst ??val))))

(def (def-inst (?name reg imm) (s8 ?w8 ?x8 . ?op8) (s32 ?w32 ?x32 . ?op32))
  (def (?name (reg ??dst) ??val)
    (sel (is? s8 ??val)        (inst-ri8 ?w8 ?x8 (1 . ?op8) ??dst ??val)
         (! (is? s32 ??val))   (error)
                               (inst-ri32 ?w32 ?x32 (1 . ?op32) ??dst ??val))))

;; Setting registers

(def (set (reg ?dst) ?val)
  (sel (! (is? s32 ?val))
       (begin
         (1 (rex 1 0 0 (>> ?dst 3)) (+ 0xb8 (& ?dst 7)))
         (8 ?val))
       (begin
         (inst-ri32 1 0 (1 0xC7) ?dst ?val))))

(def (set (u8 . ?addr) ?val)
  (inst-rm 0 (1 0xC6) 0 u8 . ?addr)
  (1 ?val))

(def (set (u32 . ?addr) ?val)
  (inst-rm 0 (1 0xC7) 0 u32 . ?addr)
  (4 ?val))

(def (set (u64 . ?addr) ?val)
  (inst-rm 1 (1 0xC7) 0 u64 . ?addr)
  (4 ?val))

(def (set (s8 . ?addr) ?val)
  (set (u8 . ?addr) ?val))

(def (set (s32 . ?addr) ?val)
  (set (u32 . ?addr) ?val))

(def (set (s64 . ?addr) ?val)
  (set (u64 . ?addr) ?val))

(def-inst (set reg _)
  (reg 1 0x89)
  (u8  0 0x0F 0xB6)    (s8  1 0x0F 0xBE)
  (u16 0 0x0F 0xB7)    (s16 1 0x0F 0xBF)
  (u32 0 0x8B)         (s32 1 0x63)
  (u64 1 0x8B)         (s64 1 0x8B))

(def-inst (set _ reg)
  (u8  0 0x40 0x88)    (s8  0 0x40 0x88)
  (u16 0 0x66 0x89)    (s16 0 0x66 0x89)
  (u32 0 0x89)         (s32 0 0x89)
  (u64 1 0x89)         (s64 1 0x89))

;; Addition

(def-inst (add reg imm)
  (s8  1 0 0x83)
  (s32 1 0 0x81))

(def-inst (add reg _)
  (reg 1 0x01))

;; Subtraction

(def-inst (sub reg imm)
  (s8  1 5 0x83)
  (s32 1 5 0x81))

(def-inst (sub reg _)
  (reg 1 0x29))

;; Multiplication

(def (mul (reg ?dst) ?val)
  (sel (is? s8 ?val)        (inst-ri8 1 ?dst (1 0x6B) ?dst ?val)
       (! (is? s32 ??val))  (error)
                            (inst-ri32 1 ?dst (1 0x69) ?dst ?val)))

(def-inst (mul _ reg)
  (reg 1 0x0F 0xAF))

(def (umul (reg ?src))
  (rex-op (rex 1 0 0 (>> ?src 3)) (1 0xF7))
  (1 (mod/rm 3 4 ?src)))

(def (smul (reg ?src))
  (rex-op (rex 1 0 0 (>> ?src 3)) (1 0xF7))
  (1 (mod/rm 3 5 ?src)))

(def (neg (reg ?src))
  (rex-op (rex 1 0 0 (>> ?src 3)) (1 0xF7))
  (1 (mod/rm 3 3 ?src)))

;; Division

(def (sign-extend)
  (rex-op (rex 1 0 0 0) (1 0x99)))

(def (udiv (reg ?src))
  (rex-op (rex 1 0 0 (>> ?src 3)) (1 0xF7))
  (1 (mod/rm 3 6 ?src)))

(def (sdiv (reg ?src))
  (rex-op (rex 1 0 0 (>> ?src 3)) (1 0xF7))
  (1 (mod/rm 3 7 ?src)))

;; Bit twiddling

(def-inst (and reg imm)
  (s8  1 4 0x83)
  (s32 1 4 0x81))

(def-inst (and reg _)
  (reg 1 0x21))

(def-inst (or reg imm)
  (s8  1 1 0x83)
  (s32 1 1 0x81))

(def-inst (or reg _)
  (reg 1 0x09))

(def-inst (xor reg imm)
  (s8  1 6 0x83)
  (s32 1 6 0x81))

(def-inst (xor reg _)
  (reg 1 0x31))

(def (not (reg ?r))
  (inst-rr 1 (1 0xf7) 2 ?r))

;; Shifting

(def (shl (reg ?r))
  (inst-rr 1 (1 0xd1) 4 ?r))

(def (shl (reg ?r) ?val)
  (inst-rr 1 (1 0xc1) 4 ?r) (1 ?val))

(def (shl (reg ?r) (reg 1))
  (inst-rr 1 (1 0xd3) 4 ?r))

(def (shr (reg ?r))
  (inst-rr 1 (1 0xd1) 5 ?r))

(def (shr (reg ?r) ?val)
  (inst-rr 1 (1 0xc1) 5 ?r) (1 ?val))

(def (shr (reg ?r) (reg 1))
  (inst-rr 1 (1 0xd3) 5 ?r))

(def (sar (reg ?r))
  (inst-rr 1 (1 0xd1) 7 ?r))

(def (sar (reg ?r) ?val)
  (inst-rr 1 (1 0xc1) 7 ?r) (1 ?val))

(def (sar (reg ?r) (reg 1))
  (inst-rr 1 (1 0xd3) 7 ?r))

;; Comparison

(def-inst (cmp reg imm)
  (s8  1 7 0x83)
  (s32 1 7 0x81))

(def-inst (cmp reg _)
  (reg 1 0x39))

;; Stack

(def (push (reg ?reg))
  (rex-op (rex 0 0 0 (>> ?reg 3)) (1 (<<< 10 5 ?reg 3))))

(def (pop (reg ?reg))
  (rex-op (rex 0 0 0 (>> ?reg 3)) (1 (<<< 11 5 ?reg 3))))

;; Jumping and calling

(def (jmp ?addr)
  (1 0xe9) (-4 ?addr))

(def (jmp (reg ?reg))
  (rex-op (rex 0 0 0 (>> ?reg 3)) (1 0xFF (<<< 28 5 ?reg 3))))

(def (je ?addr)
  (1 0x0F 0x84) (-4 ?addr))

(def (jne ?addr)
  (1 0x0F 0x85) (-4 ?addr))

(def (jl ?addr)
  (1 0x0F 0x8C) (-4 ?addr))

(def (jle ?addr)
  (1 0x0F 0x8E) (-4 ?addr))

(def (jg ?addr)
  (1 0x0F 0x8F) (-4 ?addr))

(def (jge ?addr)
  (1 0x0F 0x8D) (-4 ?addr))

(def (ja ?addr)
  (1 0x0F 0x87) (-4 ?addr))

(def (jae ?addr)
  (1 0x0F 0x83) (-4 ?addr))

(def (jb ?addr)
  (1 0x0F 0x82) (-4 ?addr))

(def (jbe ?addr)
  (1 0x0F 0x86) (-4 ?addr))

(def (call ?addr)
  (1 0xe8) (-4 ?addr))

(def (call (reg ?reg))
  (rex-op (rex 0 0 0 (>> ?reg 3)) (1 0xFF (<<< 26 5 ?reg 3))))

(def (ret)
  (1 0xc3))

;; Local variables

(def (locals-1 ?offset ((?name ?type) . ?rest))
  (def ?name (?type x0 ?offset))
  (locals-1 (+ ?offset (sizeof ?type)) ?rest))

(def (locals-1 ?offset ())
  (push x0)
  (sub sp ?offset)
  (set x0 sp))

(def (locals ?vars)
  (locals-1 0 ?vars))

(def (end-locals)
  (set sp x0)
  (pop x0))

;; Init

(code start
  (jmp main))
